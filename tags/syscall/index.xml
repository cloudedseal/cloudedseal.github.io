<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>keep doing – Syscall</title><link>https://cloudedseal.github.io/tags/syscall/</link><description>Recent content in Syscall on keep doing</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 27 Jul 2025 17:45:55 +0800</lastBuildDate><atom:link href="https://cloudedseal.github.io/tags/syscall/index.xml" rel="self" type="application/rss+xml"/><item><title>Syscall Details</title><link>https://cloudedseal.github.io/blog/syscall-details/</link><pubDate>Sun, 27 Jul 2025 17:45:55 +0800</pubDate><guid>https://cloudedseal.github.io/blog/syscall-details/</guid><description>
&lt;h3>什么是操作系统？&lt;span class="hx-absolute -hx-mt-20" id="什么是操作系统">&lt;/span>
&lt;a href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>os 初始状态 + syscalls&lt;/p>
&lt;p>When a user program issues a system call, the operating system (OS) and hardware collaborate to transition from user mode to kernel mode, execute &lt;code>privileged&lt;/code> operations, and safely return control to the user program.&lt;/p>
&lt;h3>&lt;strong>1. Issuing the System Call&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="1-issuing-the-system-call">&lt;/span>
&lt;a href="#1-issuing-the-system-call" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>&lt;strong>User Program Action&lt;/strong>: The program invokes a system call (e.g., &lt;code>read()&lt;/code> or &lt;code>write()&lt;/code>) via a library function (e.g., &lt;code>libc&lt;/code>).&lt;/li>
&lt;li>&lt;strong>Setup&lt;/strong>: The library function prepares:
&lt;ul>
&lt;li>&lt;strong>System Call Number&lt;/strong>: Identifies the requested service (e.g., stored in &lt;code>RAX&lt;/code> on x86-64).&lt;/li>
&lt;li>&lt;strong>Arguments&lt;/strong>: Passed via registers (e.g., &lt;code>RDI&lt;/code>, &lt;code>RSI&lt;/code>, &lt;code>RDX&lt;/code> on x86-64).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Trigger&lt;/strong>: Executes a hardware instruction (e.g., &lt;code>syscall&lt;/code> on x86-64, &lt;code>svc&lt;/code> on ARM, or &lt;code>int 0x80&lt;/code> for legacy x86) to switch to kernel mode.&lt;/li>
&lt;/ul>
&lt;h3>&lt;strong>2. Hardware Transition to Kernel Mode&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="2-hardware-transition-to-kernel-mode">&lt;/span>
&lt;a href="#2-hardware-transition-to-kernel-mode" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Privilege Elevation&lt;/strong>: The CPU switches from &lt;strong>user mode&lt;/strong> (limited privileges) to &lt;strong>kernel mode&lt;/strong> (full privileges).&lt;/li>
&lt;li>&lt;strong>Interrupt Handling&lt;/strong>:
&lt;ul>
&lt;li>The CPU consults the &lt;strong>Interrupt Descriptor Table (IDT)&lt;/strong> or system call entry point to locate the kernel&amp;rsquo;s handler.&lt;/li>
&lt;li>The &lt;strong>Memory Management Unit (MMU)&lt;/strong> enforces memory protection, ensuring user programs cannot access kernel memory.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Context Save&lt;/strong>:
&lt;ul>
&lt;li>The CPU saves the user program’s state (registers, program counter, stack pointer, flags) to the &lt;strong>kernel stack&lt;/strong> (not the user stack).&lt;/li>
&lt;li>The kernel stack is per-process and isolated for security.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3>&lt;strong>3. Kernel Executes the System Call&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="3-kernel-executes-the-system-call">&lt;/span>
&lt;a href="#3-kernel-executes-the-system-call" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Handler Invocation&lt;/strong>: The kernel’s system call dispatcher uses the system call number to jump to the appropriate handler (e.g., &lt;code>sys_read()&lt;/code> or &lt;code>sys_write()&lt;/code>).&lt;/li>
&lt;li>&lt;strong>Privileged Operations&lt;/strong>:
&lt;ul>
&lt;li>The kernel performs tasks like I/O, file access, or memory allocation, interacting directly with hardware if needed.&lt;/li>
&lt;li>If the operation blocks (e.g., waiting for disk data), the process may be paused, and the scheduler switches to another task.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Result Preparation&lt;/strong>: The return value (or error code) is stored in a register (e.g., &lt;code>RAX&lt;/code> on x86-64).&lt;/li>
&lt;/ul>
&lt;h3>&lt;strong>4. Returning to User Mode&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="4-returning-to-user-mode">&lt;/span>
&lt;a href="#4-returning-to-user-mode" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Context Restoration&lt;/strong>: The kernel restores the saved user state (registers, program counter) from the kernel stack.&lt;/li>
&lt;li>&lt;strong>Mode Switch&lt;/strong>: The CPU executes a return instruction (e.g., &lt;code>sysret&lt;/code> or &lt;code>iret&lt;/code> on x86), switching back to &lt;strong>user mode&lt;/strong>.&lt;/li>
&lt;li>&lt;strong>Resumption&lt;/strong>: The user program continues execution at the next instruction, typically checking the return value for success/error.&lt;/li>
&lt;/ul>
&lt;h3>&lt;strong>Hardware and OS Roles&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="hardware-and-os-roles">&lt;/span>
&lt;a href="#hardware-and-os-roles" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>&lt;strong>CPU&lt;/strong>: Manages privilege levels, mode transitions, and instruction execution.&lt;/li>
&lt;li>&lt;strong>MMU&lt;/strong>: Enforces memory isolation between user and kernel spaces.&lt;/li>
&lt;li>&lt;strong>Kernel&lt;/strong>: Provides system call handlers, manages resources, and ensures security.&lt;/li>
&lt;/ul>
&lt;h3>&lt;strong>Summary&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="summary">&lt;/span>
&lt;a href="#summary" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>&lt;strong>User-to-Kernel Transition&lt;/strong>: Hardware elevates privileges, saves state, and jumps to the kernel.&lt;/li>
&lt;li>&lt;strong>Kernel Execution&lt;/strong>: Performs the requested service using privileged operations.&lt;/li>
&lt;li>&lt;strong>Kernel-to-User Transition&lt;/strong>: Restores user state, drops privileges, and resumes the user program.&lt;/li>
&lt;/ul>
&lt;p>This controlled interaction ensures user programs can safely access OS services without compromising system stability or security.&lt;/p>
&lt;h1>References&lt;/h1>&lt;ol>
&lt;li>&lt;a href="https://kib.kiev.ua/x86docs/AMD/MISC/21086C.pdf" target="_blank" rel="noopener">https://kib.kiev.ua/x86docs/AMD/MISC/21086C.pdf&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Syscall Futex</title><link>https://cloudedseal.github.io/blog/syscall-futex/</link><pubDate>Mon, 05 May 2025 17:45:55 +0800</pubDate><guid>https://cloudedseal.github.io/blog/syscall-futex/</guid><description>
&lt;p>&lt;strong>Futex (Fast Userspace Mutex)&lt;/strong>&lt;/p>
&lt;p>A &lt;strong>futex&lt;/strong> is a Linux kernel system call that provides a fast and efficient mechanism for implementing &lt;code>user-space synchronization&lt;/code> primitives, such as mutexes, semaphores, and condition variables. It &lt;code>minimizes&lt;/code> kernel involvement &lt;code>in uncontended cases&lt;/code>, reducing overhead by handling synchronization in userspace when possible.&lt;/p>
&lt;blockquote>
&lt;p>Futexes split synchronization into &lt;strong>user-space atomics&lt;/strong> (fast) and &lt;strong>kernel-assisted blocking&lt;/strong> (slow), optimizing for the common case. The boundary is enforced by hardware (CPU modes) and the need for kernel-managed resources (scheduling, interrupts).&lt;/p>
&lt;/blockquote>
&lt;h2>&lt;strong>How Futex Works?&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="how-futex-works">&lt;/span>
&lt;a href="#how-futex-works" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;ol>
&lt;li>没有竞争，CAS 后直接获取锁，不涉及到 syscall&lt;/li>
&lt;li>有竞争, futex_wait 让线程 sleep, 等待其他线程 futex_wake 唤醒&lt;/li>
&lt;/ol>
&lt;p>大多数时候是没有竞争的，所以就减少了内核的干预。&lt;/p>
&lt;h3>&lt;strong>futex 设计原则&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="futex-设计原则">&lt;/span>
&lt;a href="#futex-%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;h4>&lt;strong>Avoid Kernel Calls When Possible&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="avoid-kernel-calls-when-possible">&lt;/span>
&lt;a href="#avoid-kernel-calls-when-possible" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>Use &lt;code>atomic operations&lt;/code> for &lt;code>uncontended cases&lt;/code> (fast path).&lt;/li>
&lt;li>Only call the kernel when blocking is required (slow path).&lt;/li>
&lt;/ul>
&lt;h4>&lt;strong>Kernel as a Backstop&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="kernel-as-a-backstop">&lt;/span>
&lt;a href="#kernel-as-a-backstop" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>The kernel handles complex tasks like:
&lt;ul>
&lt;li>Managing wait queues.&lt;/li>
&lt;li>Guaranteeing fairness/priority in thread wakeup.&lt;/li>
&lt;li>Handling signals/interrupts during blocking.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4>&lt;strong>Spurious Wakeups&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="spurious-wakeups">&lt;/span>
&lt;a href="#spurious-wakeups" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>The kernel may wake threads even if the futex value hasn’t changed (e.g., due to &lt;code>signals&lt;/code>).&lt;/li>
&lt;li>&lt;strong>User-space must &lt;code>recheck&lt;/code> the futex value&lt;/strong> after wakeup (e.g., loop in &lt;code>lock()&lt;/code>).&lt;/li>
&lt;/ul>
&lt;h3>&lt;strong>为啥需要减少内核的干预?&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="为啥需要减少内核的干预">&lt;/span>
&lt;a href="#%e4%b8%ba%e5%95%a5%e9%9c%80%e8%a6%81%e5%87%8f%e5%b0%91%e5%86%85%e6%a0%b8%e7%9a%84%e5%b9%b2%e9%a2%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>Kernel calls (system calls) are &lt;strong>expensive&lt;/strong> compared to user-space operations.&lt;/p>
&lt;h4>&lt;strong>Context Switch Overhead&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="context-switch-overhead">&lt;/span>
&lt;a href="#context-switch-overhead" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>When a thread enters the kernel (e.g., via &lt;code>syscall&lt;/code>), the CPU must:
&lt;ul>
&lt;li>Save user-space registers. 保存用户空间寄存器&lt;/li>
&lt;li>Switch to kernel mode (privileged CPU state). CPU 模式切换到特权模式&lt;/li>
&lt;li>Run kernel code (e.g., scheduler, wait queues). 执行内核代码，比如调度器&lt;/li>
&lt;li>Restore user-space state afterward. 恢复用户空间寄存器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>This process takes &lt;strong>hundreds to thousands of CPU cycles&lt;/strong>, adding latency.&lt;/li>
&lt;/ul>
&lt;h4>&lt;strong>Scalability&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="scalability">&lt;/span>
&lt;a href="#scalability" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>Frequent kernel calls create contention in the &lt;code>kernel’s internal data structures&lt;/code> (e.g., locks for process/thread management).&lt;/li>
&lt;li>Kernel resources are shared &lt;code>across all processes&lt;/code>, so overuse hurts overall system performance. 所有进程共享内核资源&lt;/li>
&lt;/ul>
&lt;h4>&lt;strong>Fast-Path Optimization&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="fast-path-optimization">&lt;/span>
&lt;a href="#fast-path-optimization" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>Most synchronization operations (e.g., locking a mutex) are &lt;strong>uncontended&lt;/strong> (no other thread holds the lock).&lt;/li>
&lt;li>Handling these cases purely in user-space avoids kernel interaction entirely.&lt;/li>
&lt;/ul>
&lt;h4>&lt;strong>User Space and Kernel 边界&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="user-space-and-kernel-边界">&lt;/span>
&lt;a href="#user-space-and-kernel-%e8%be%b9%e7%95%8c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>The boundary is defined by &lt;strong>CPU privilege levels&lt;/strong> and the need for kernel-managed resources:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>User Space&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Kernel Space&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Runs in unprivileged CPU mode (ring 3).&lt;/td>
&lt;td>Runs in privileged CPU mode (ring 0).&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Directly manipulates user memory.&lt;/td>
&lt;td>Manages hardware, interrupts, scheduling.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Uses atomic CPU instructions (e.g., &lt;code>cmpxchg&lt;/code>).&lt;/td>
&lt;td>Uses system calls (e.g., &lt;code>futex&lt;/code>, &lt;code>sched_yield&lt;/code>).&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Handles &amp;ldquo;fast path&amp;rdquo; (uncontended case).&lt;/td>
&lt;td>Manages &amp;ldquo;slow path&amp;rdquo; (blocking/waking threads).&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2>&lt;strong>Futex: Balancing User/Kernel Responsibilities&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="futex-balancing-userkernel-responsibilities">&lt;/span>
&lt;a href="#futex-balancing-userkernel-responsibilities" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>&lt;code>futex&lt;/code> 横跨 user/kernel 两个空间&lt;/p>
&lt;h3>&lt;strong>User-Space Fast Path (No Contention)&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="user-space-fast-path-no-contention">&lt;/span>
&lt;a href="#user-space-fast-path-no-contention" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Atomic Compare-and-Swap (CAS):&lt;/strong>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">atomic_compare_exchange_strong&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">futex&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// Pure user-space
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>If the lock is free (&lt;code>futex == 0&lt;/code>), the thread acquires it &lt;strong>without involving the kernel&lt;/strong>.&lt;/li>
&lt;li>This is a single CPU instruction (e.g., &lt;code>lock cmpxchg&lt;/code> on x86), blazing fast.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3>&lt;strong>Kernel Slow Path (Contention)&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="kernel-slow-path-contention">&lt;/span>
&lt;a href="#kernel-slow-path-contention" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;h4>&lt;strong>Blocking with &lt;code>FUTEX_WAIT&lt;/code>&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="blocking-with">&lt;/span>
&lt;a href="#blocking-with" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">syscall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SYS_futex&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">futex&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">FUTEX_WAIT&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...);&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>If the lock is held (&lt;code>futex == 1&lt;/code>), the thread asks the kernel to &lt;strong>block it&lt;/strong> until the lock is freed.&lt;/li>
&lt;li>The kernel adds the thread to a &lt;code>wait queue&lt;/code> and &lt;code>schedules other threads&lt;/code>.&lt;/li>
&lt;/ul>
&lt;h4>&lt;strong>Waking with &lt;code>FUTEX_WAKE&lt;/code>&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="waking-with">&lt;/span>
&lt;a href="#waking-with" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">syscall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SYS_futex&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">futex&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">FUTEX_WAKE&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...);&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>&lt;code>On unlock&lt;/code>, the kernel &lt;code>wakes&lt;/code> one blocked thread.&lt;/li>
&lt;li>This involves &lt;code>scheduler&lt;/code> logic (kernel responsibility).&lt;/li>
&lt;/ul>
&lt;h3>&lt;strong>Futex 主要操作&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="futex-主要操作">&lt;/span>
&lt;a href="#futex-%e4%b8%bb%e8%a6%81%e6%93%8d%e4%bd%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>&lt;strong>&lt;code>FUTEX_WAIT&lt;/code>&lt;/strong>: Puts the calling thread to &lt;code>sleep&lt;/code> if the futex word matches the expected value.&lt;/li>
&lt;/ul>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;pre>&lt;code> If *uaddr == val, the thread goes to sleep (blocks).
If *uaddr != val, the call returns immediately with EAGAIN.
If a timeout is set, the thread may also wake up due to timeout (ETIMEDOUT).&lt;/code>&lt;/pre>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>&lt;strong>&lt;code>FUTEX_WAKE&lt;/code>&lt;/strong>: Wakes up a specified number of threads waiting on the futex.&lt;/li>
&lt;li>&lt;strong>&lt;code>FUTEX_WAIT_BITSET&lt;/code> / &lt;code>FUTEX_WAKE_BITSET&lt;/code>&lt;/strong>: Advanced operations for conditional waits using bitmasks (e.g., for condition variables).&lt;/li>
&lt;/ul>
&lt;h3>&lt;strong>工作流程示例&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="工作流程示例">&lt;/span>
&lt;a href="#%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b%e7%a4%ba%e4%be%8b" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>Thread A acquires the lock:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>CAS succeeds in user space (&lt;code>futex&lt;/code> becomes 1).&lt;/li>
&lt;li>No kernel interaction.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Thread B tries to acquire the lock:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>CAS fails (futex is 1).&lt;/li>
&lt;li>Calls &lt;code>FUTEX_WAIT&lt;/code> to block (kernel involvement).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Thread A releases the lock:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Sets &lt;code>futex&lt;/code> to 0 (user space).&lt;/li>
&lt;li>Calls &lt;code>FUTEX_WAKE&lt;/code> to unblock Thread B (kernel).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>&lt;strong>Why This Matters in Practice?&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="why-this-matters-in-practice">&lt;/span>
&lt;a href="#why-this-matters-in-practice" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Performance:&lt;/strong> A futex-based mutex can be &lt;strong>10–100x faster&lt;/strong> than a traditional kernel-only mutex under low contention.&lt;/li>
&lt;li>&lt;strong>Scalability:&lt;/strong> Reduces kernel lock contention in highly parallel workloads (e.g., databases, game engines).&lt;/li>
&lt;li>&lt;strong>Flexibility:&lt;/strong> User-space can implement custom synchronization logic (e.g., adaptive mutexes, read/write locks).&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Core Concept&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>A &lt;strong>futex word&lt;/strong> (a 32-bit integer in shared memory) acts as the synchronization variable. 和平台无关, 都是 32bit&lt;/li>
&lt;li>Threads use atomic operations (e.g., compare-and-swap) to manipulate this word in userspace.&lt;/li>
&lt;li>Kernel intervention occurs &lt;strong>only during contention&lt;/strong> (e.g., when a thread must wait).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Acquiring a Lock (&lt;code>Uncontended Case&lt;/code>)&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>A thread attempts to atomically set the futex word from &lt;code>0&lt;/code> (unlocked) to &lt;code>1&lt;/code> (locked).&lt;/li>
&lt;li>If successful, the lock is acquired without a system call.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Acquiring a Lock (&lt;code>Contended Case&lt;/code>)&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>If the lock is already held (&lt;code>futex_word == 1&lt;/code>), the thread calls &lt;code>futex_wait(&amp;amp;futex_word, 1)&lt;/code> to block.&lt;/li>
&lt;li>The kernel checks if the futex word is still &lt;code>1&lt;/code> and puts the thread to sleep, avoiding race conditions.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Releasing a Lock&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>The thread sets the futex word back to &lt;code>0&lt;/code> atomically.&lt;/li>
&lt;li>It then calls &lt;code>futex_wake(&amp;amp;futex_word, 1)&lt;/code> to wake up one waiting thread.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Handling Spurious Wakeups&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>After waking, threads &lt;strong>re-check&lt;/strong> the futex word to ensure the lock is available before proceeding.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>&lt;strong>例子理解&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="例子理解">&lt;/span>
&lt;a href="#%e4%be%8b%e5%ad%90%e7%90%86%e8%a7%a3" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div class="filename not-prose" dir="auto">futex_demo.c&lt;/div>&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;linux/futex.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;sys/syscall.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;pthread.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Futex word (shared between threads)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">futex_var&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 0 = unlocked, 1 = locked
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Wrapper for futex_wait syscall
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">futex_wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">uaddr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">val&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">syscall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SYS_futex&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uaddr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">FUTEX_WAIT&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">val&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Wrapper for futex_wake syscall
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">futex_wake&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">uaddr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">syscall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SYS_futex&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uaddr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">FUTEX_WAKE&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Thread function with custom sleep time
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">thread_func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">arg&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">sleep_time&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">arg&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// Cast void* to int*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Try to acquire lock (using GCC atomic compare-and-swap)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">expected&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="nf">__sync_bool_compare_and_swap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">futex_var&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Contended case: wait for wakeups
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Thread %lu acquired the lock failed&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nf">pthread_self&lt;/span>&lt;span class="p">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">futex_wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">futex_var&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Critical section (simulate work with custom sleep)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Thread %lu acquired the lock success, sleeping for %d seconds&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">pthread_self&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">sleep_time&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sleep_time&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// Customizable sleep duration
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Release lock
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">futex_var&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">futex_wake&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">futex_var&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Define sleep durations for each thread
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">sleep1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// First thread sleeps for 1 second
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">sleep2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// Second thread sleeps for 3 seconds
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">sleep3&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Create threads
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">pthread_t&lt;/span> &lt;span class="n">t1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">t2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">t3&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%p&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">futex_var&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">pthread_create&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">thread_func&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">sleep1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">pthread_create&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">t2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">thread_func&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">sleep2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">pthread_create&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">t3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">thread_func&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">sleep3&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Wait for threads to finish
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">pthread_join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">pthread_join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">t2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">pthread_join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">t3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-8">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;blockquote>
&lt;p>gcc -g -pthread -std=gnu11 futex_demo.c -o futex_demo&lt;/p>
&lt;/blockquote>
&lt;h2>&lt;strong>什么是 Spurious Wakeup?&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="什么是-spurious-wakeup">&lt;/span>
&lt;a href="#%e4%bb%80%e4%b9%88%e6%98%af-spurious-wakeup" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>A &lt;strong>spurious wakeup&lt;/strong> occurs when a thread waiting on a synchronization primitive (e.g., a condition variable, futex, or semaphore) &lt;strong>wakes up without being explicitly signaled or broadcasted&lt;/strong>. This means the thread resumes execution even though no other thread modified the condition it was waiting for.&lt;/p>
&lt;p>Spurious wakeups are &lt;strong>not errors&lt;/strong> in the system.
they are a design trade-off in low-level synchronization mechanisms like futexes to &lt;strong>avoid unnecessary overhead&lt;/strong> in kernel-space implementations.&lt;/p>
&lt;h3>&lt;strong>为啥需要 spurious Wakeups?&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="为啥需要-spurious-wakeups">&lt;/span>
&lt;a href="#%e4%b8%ba%e5%95%a5%e9%9c%80%e8%a6%81-spurious-wakeups" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>spurious wakeups are allowed for &lt;strong>performance and implementation efficiency&lt;/strong>, particularly in systems like Linux futexes.&lt;/p>
&lt;p>为了性能和高效的实现需要 spurious wakeups&lt;/p>
&lt;h4>1. &lt;strong>Kernel Optimization&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="1-kernel-optimization">&lt;/span>
&lt;a href="#1-kernel-optimization" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>The Linux kernel uses shared data structures (e.g., wait queues) for threads waiting on a futex. If multiple threads are waiting on the same futex word, the kernel may wake up &lt;strong>more than one thread&lt;/strong> (even if only one is needed) to reduce contention and latency.&lt;/li>
&lt;li>This avoids the overhead of tracking exactly which thread should wake up.&lt;/li>
&lt;/ul>
&lt;h4>2. &lt;strong>Signal Handling&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="2-signal-handling">&lt;/span>
&lt;a href="#2-signal-handling" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>A thread waiting on a futex may be interrupted by a &lt;strong>signal&lt;/strong> (e.g., &lt;code>SIGINT&lt;/code>, &lt;code>SIGALRM&lt;/code>). The kernel wakes up the thread to handle the signal, even if the futex condition hasn’t changed.&lt;/li>
&lt;/ul>
&lt;h4>3. &lt;strong>Hardware/Architecture Constraints&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="3-hardwarearchitecture-constraints">&lt;/span>
&lt;a href="#3-hardwarearchitecture-constraints" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>Some architectures or hardware may not guarantee atomicity between checking the condition and sleeping, leading to race conditions that require re-checking after waking.&lt;/li>
&lt;/ul>
&lt;h2>&lt;strong>什么情况会发生 Spurious Wakeups?&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="什么情况会发生-spurious-wakeups">&lt;/span>
&lt;a href="#%e4%bb%80%e4%b9%88%e6%83%85%e5%86%b5%e4%bc%9a%e5%8f%91%e7%94%9f-spurious-wakeups" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Scenario&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Multiple Waiters&lt;/strong>&lt;/td>
&lt;td>When many threads wait on the same futex, the kernel may wake multiple threads (e.g., via &lt;code>FUTEX_WAKE&lt;/code>) even if only one is needed.&lt;br/> 多个等待同一个 futex 的线程, 被 os 一并唤醒, 但最终只有一个获取 futex&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Signal Interruption&lt;/strong>&lt;/td>
&lt;td>A thread is interrupted by a signal (e.g., Ctrl+C), causing it to wake up prematurely.&lt;br> 虽然进程 sleep 了, 但是仍可以被 os 唤醒处理信号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Timeout Expiration&lt;/strong>&lt;/td>
&lt;td>If a timeout is set (e.g., &lt;code>FUTEX_WAIT_BITSET&lt;/code> with a timeout), the thread may wake up due to the timeout, even if the condition hasn’t changed.&lt;br/> 设置了超时, 超时后可以被 os 唤醒&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Kernel Preemption&lt;/strong>&lt;/td>
&lt;td>In high-load scenarios, the kernel may preempt a waiting thread for scheduling reasons. &lt;br/> 被 os 抢占调度唤醒&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3>&lt;strong>如何处理 Spurious Wakeups?&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="如何处理-spurious-wakeups">&lt;/span>
&lt;a href="#%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86-spurious-wakeups" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>To handle spurious wakeups correctly, &lt;strong>always re-check the condition&lt;/strong> after waking up. This is a fundamental rule in concurrent programming.&lt;/p>
&lt;h4>&lt;strong>例子1 重新检查条件&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="例子1-重新检查条件">&lt;/span>
&lt;a href="#%e4%be%8b%e5%ad%901-%e9%87%8d%e6%96%b0%e6%a3%80%e6%9f%a5%e6%9d%a1%e4%bb%b6" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Shared futex word (0 = unlocked, 1 = locked)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">futex_var&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Thread attempts to acquire the lock
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="nf">__sync_bool_compare_and_swap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">futex_var&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Wait for wakeups if futex_var is still 1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">futex_wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">futex_var&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>Here’s what happens:&lt;/p>
&lt;ol>
&lt;li>If &lt;code>futex_wait&lt;/code> returns due to a spurious wakeup, the thread &lt;strong>re-checks the condition&lt;/strong> (&lt;code>futex_var == 1&lt;/code>) in the loop.&lt;/li>
&lt;li>If the condition is still true, the thread calls &lt;code>futex_wait&lt;/code> again.&lt;/li>
&lt;li>If the condition is now false (e.g., another thread released the lock), the thread proceeds.&lt;/li>
&lt;/ol>
&lt;h4>&lt;strong>例子2 重新检查条件&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="例子2-重新检查条件">&lt;/span>
&lt;a href="#%e4%be%8b%e5%ad%902-%e9%87%8d%e6%96%b0%e6%a3%80%e6%9f%a5%e6%9d%a1%e4%bb%b6" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">pthread_mutex_lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">condition_met&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">pthread_cond_wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">cond&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// Releases mutex, waits for signal
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Re-check condition here (spurious wakeups handled by the loop)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">pthread_mutex_unlock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>The &lt;code>while&lt;/code> loop ensures that spurious wakeups are harmless.&lt;/p>
&lt;h3>&lt;strong>Why Not Prevent Spurious Wakeups?&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="why-not-prevent-spurious-wakeups">&lt;/span>
&lt;a href="#why-not-prevent-spurious-wakeups" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>Preventing spurious wakeups would require &lt;strong>strict guarantees&lt;/strong> from the kernel or library, which could introduce significant overhead. For example:&lt;/p>
&lt;ul>
&lt;li>Tracking exactly which thread should wake up (e.g., via a queue).&lt;/li>
&lt;li>Adding memory barriers or locks to ensure atomicity between checking and sleeping.&lt;/li>
&lt;/ul>
&lt;p>By allowing spurious wakeups, systems like futexes remain lightweight and scalable for high-performance applications.&lt;/p></description></item><item><title>Asm How Glibc Wrap Syscall</title><link>https://cloudedseal.github.io/blog/asm-how-glibc-wrap-syscall/</link><pubDate>Mon, 21 Apr 2025 15:34:28 +0800</pubDate><guid>https://cloudedseal.github.io/blog/asm-how-glibc-wrap-syscall/</guid><description>
&lt;blockquote>
&lt;p>实验平台: x86_64 GNU/Linux mint22.1&lt;/p>
&lt;/blockquote>
&lt;h2>使用 &lt;code>glibc&lt;/code> 的函数&lt;span class="hx-absolute -hx-mt-20" id="使用-glibc-的函数">&lt;/span>
&lt;a href="#%e4%bd%bf%e7%94%a8-glibc-%e7%9a%84%e5%87%bd%e6%95%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>write1.c&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">msg&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;Hello, glibc!&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">msg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">msg&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// glibc&amp;#39;s write() wrapper
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol>
&lt;li>gcc -o write1 write1.c&lt;/li>
&lt;li>使用 &lt;code>ltrace ./write1&lt;/code> 查看调用了 write 库函数&lt;/li>
&lt;/ol>
&lt;h2>不使用 glibc 的函数&lt;span class="hx-absolute -hx-mt-20" id="不使用-glibc-的函数">&lt;/span>
&lt;a href="#%e4%b8%8d%e4%bd%bf%e7%94%a8-glibc-%e7%9a%84%e5%87%bd%e6%95%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>write2.c&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;errno.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;syscall.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">ssize_t&lt;/span> &lt;span class="nf">write_no_glibc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">size_t&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">long&lt;/span> &lt;span class="n">ret&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">asm&lt;/span> &lt;span class="k">volatile&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;syscall&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">:&lt;/span> &lt;span class="s">&amp;#34;=a&amp;#34;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ret&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// Output: result in rax
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="s">&amp;#34;a&amp;#34;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">__NR_write&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s">&amp;#34;D&amp;#34;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s">&amp;#34;S&amp;#34;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s">&amp;#34;d&amp;#34;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// Inputs
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="s">&amp;#34;rcx&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;r11&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;memory&amp;#34;&lt;/span> &lt;span class="c1">// Clobbered registers
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">ret&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">errno&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">ret&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// Set errno on error
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">ret&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// Return bytes written
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">msg&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;Hello, glibc!&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">write_no_glibc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">msg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">msg&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol>
&lt;li>gcc -o write2 write2.c&lt;/li>
&lt;li>使用 &lt;code>ltrace ./write2&lt;/code> 查看没有调用 write 库函数&lt;/li>
&lt;/ol>
&lt;h2>How glibc Wraps System Calls​​&lt;span class="hx-absolute -hx-mt-20" id="how-glibc-wraps-system-calls">&lt;/span>
&lt;a href="#how-glibc-wraps-system-calls" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;h3>​System Call Number​​&lt;span class="hx-absolute -hx-mt-20" id="system-call-number">&lt;/span>
&lt;a href="#system-call-number" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>Each system call (e.g., write, read) is assigned a &lt;code>unique number&lt;/code> (e.g., __NR_write). 要使用哪一个 syscall&lt;/p>
&lt;h3>Argument Setup​​&lt;span class="hx-absolute -hx-mt-20" id="argument-setup">&lt;/span>
&lt;a href="#argument-setup" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>The wrapper loads the system call number and arguments into specific registers (architecture-dependent). 设置 syscall 的参数&lt;/p>
&lt;h3>​Kernel Transition​​&lt;span class="hx-absolute -hx-mt-20" id="kernel-transition">&lt;/span>
&lt;a href="#kernel-transition" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>The wrapper uses an instruction like syscall (x86-64) to switch to kernel mode. 进入 kernel mode&lt;/p>
&lt;h3>Result Handling​​&lt;span class="hx-absolute -hx-mt-20" id="result-handling">&lt;/span>
&lt;a href="#result-handling" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>After the kernel finishes, the wrapper checks for errors, sets errno if needed, and returns the result. 处理返回值&lt;/p>
&lt;h2>References&lt;span class="hx-absolute -hx-mt-20" id="references">&lt;/span>
&lt;a href="#references" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;ol>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/ltrace.1.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man1/ltrace.1.html&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Cmd Strace</title><link>https://cloudedseal.github.io/blog/cmd-strace/</link><pubDate>Sat, 19 Apr 2025 16:29:04 +0800</pubDate><guid>https://cloudedseal.github.io/blog/cmd-strace/</guid><description>
&lt;h1>syscall&lt;/h1>&lt;p>操作系统运行在 kernel space, 拥有整个系统的控制权。
应用程序运行在 user space, 拥有部分权限。
这就是隔离。
To prevent user applications from &lt;code>accessing or modifying&lt;/code> critical operating system data.
想让操作系统做些事情怎么办？使用 syscall。&lt;/p>
&lt;h1>strace&lt;/h1>&lt;h2>strace -t -ff -o MainTest.log -f java MainTest&lt;span class="hx-absolute -hx-mt-20" id="strace--t--ff--o-maintestlog--f--java-maintest">&lt;/span>
&lt;a href="#strace--t--ff--o-maintestlog--f--java-maintest" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;ol>
&lt;li>&lt;code>-t&lt;/code> time&lt;/li>
&lt;li>&lt;code>-ff&lt;/code> follow-fork&lt;/li>
&lt;li>&lt;code>-o&lt;/code> output&lt;/li>
&lt;/ol>
&lt;h2>strace -tt -ff -o MainTest.log -f -e trace=futex,write java MainTest&lt;span class="hx-absolute -hx-mt-20" id="strace--tt--ff--o-maintestlog---f--e-tracefutexwrite-java-maintest">&lt;/span>
&lt;a href="#strace--tt--ff--o-maintestlog---f--e-tracefutexwrite-java-maintest" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;blockquote>
&lt;p>-ff -o 每一个进程的 log 单独写到一个文件&lt;/p>
&lt;/blockquote>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">-rw-rw-r-- &lt;span class="m">1&lt;/span> yang yang &lt;span class="m">13468&lt;/span> Apr &lt;span class="m">20&lt;/span> 21:10 MainTest.log.21792
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-rw-rw-r-- &lt;span class="m">1&lt;/span> yang yang &lt;span class="m">455425&lt;/span> Apr &lt;span class="m">20&lt;/span> 21:10 MainTest.log.21793
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-rw-rw-r-- &lt;span class="m">1&lt;/span> yang yang &lt;span class="m">1254&lt;/span> Apr &lt;span class="m">20&lt;/span> 21:10 MainTest.log.21794
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-rw-rw-r-- &lt;span class="m">1&lt;/span> yang yang &lt;span class="m">1361&lt;/span> Apr &lt;span class="m">20&lt;/span> 21:10 MainTest.log.21795
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-rw-rw-r-- &lt;span class="m">1&lt;/span> yang yang &lt;span class="m">3802&lt;/span> Apr &lt;span class="m">20&lt;/span> 21:10 MainTest.log.21796
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-rw-rw-r-- &lt;span class="m">1&lt;/span> yang yang &lt;span class="m">1677&lt;/span> Apr &lt;span class="m">20&lt;/span> 21:10 MainTest.log.21797
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-rw-rw-r-- &lt;span class="m">1&lt;/span> yang yang &lt;span class="m">1705&lt;/span> Apr &lt;span class="m">20&lt;/span> 21:10 MainTest.log.21798
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-rw-rw-r-- &lt;span class="m">1&lt;/span> yang yang &lt;span class="m">1797&lt;/span> Apr &lt;span class="m">20&lt;/span> 21:10 MainTest.log.21810
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-rw-rw-r-- &lt;span class="m">1&lt;/span> yang yang &lt;span class="m">6087&lt;/span> Apr &lt;span class="m">20&lt;/span> 21:10 MainTest.log.21811
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-rw-rw-r-- &lt;span class="m">1&lt;/span> yang yang &lt;span class="m">5541&lt;/span> Apr &lt;span class="m">20&lt;/span> 21:10 MainTest.log.21812
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-rw-rw-r-- &lt;span class="m">1&lt;/span> yang yang &lt;span class="m">1444&lt;/span> Apr &lt;span class="m">20&lt;/span> 21:10 MainTest.log.21813
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-rw-rw-r-- &lt;span class="m">1&lt;/span> yang yang &lt;span class="m">33890&lt;/span> Apr &lt;span class="m">20&lt;/span> 21:10 MainTest.log.21814
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-rw-rw-r-- &lt;span class="m">1&lt;/span> yang yang &lt;span class="m">3996&lt;/span> Apr &lt;span class="m">20&lt;/span> 21:10 MainTest.log.21822&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h2>strace -tt -ff -o MainTest.log -f -e trace=futex,write java MainTest&lt;span class="hx-absolute -hx-mt-20" id="strace--tt--ff--o-maintestlog---f--e-tracefutexwrite--java-maintest">&lt;/span>
&lt;a href="#strace--tt--ff--o-maintestlog---f--e-tracefutexwrite--java-maintest" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;blockquote>
&lt;p>-e expr 多个 syscall CSV 形式&lt;/p>
&lt;/blockquote>
&lt;h2>strace -tt -ff -o MainTest.log -f -e trace=%process java MainTest&lt;span class="hx-absolute -hx-mt-20" id="strace--tt--ff--o-maintestlog---f--e-traceprocess-java-maintest">&lt;/span>
&lt;a href="#strace--tt--ff--o-maintestlog---f--e-traceprocess-java-maintest" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;h2>strace -tt -ff -o MainTest.log -f -e trace=%memory -a java MainTest&lt;span class="hx-absolute -hx-mt-20" id="strace--tt--ff--o-maintestlog---f--e-tracememory--a-java-maintest">&lt;/span>
&lt;a href="#strace--tt--ff--o-maintestlog---f--e-tracememory--a-java-maintest" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;h2>strace -tt -ff -o MainTest.log -f -e trace=%ipc java MainTest&lt;span class="hx-absolute -hx-mt-20" id="strace--tt--ff--o-maintestlog---f--e-traceipc--java-maintest">&lt;/span>
&lt;a href="#strace--tt--ff--o-maintestlog---f--e-traceipc--java-maintest" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;h1>References&lt;/h1>&lt;ol>
&lt;li>&lt;a href="https://jvns.ca/strace-zine-v2.pdf" target="_blank" rel="noopener">https://jvns.ca/strace-zine-v2.pdf&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/strace.1.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man1/strace.1.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://strace.io/" target="_blank" rel="noopener">https://strace.io/&lt;/a>&lt;/li>
&lt;/ol></description></item></channel></rss>