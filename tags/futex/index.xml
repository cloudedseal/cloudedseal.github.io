<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>keep doing – Futex</title><link>https://cloudedseal.github.io/tags/futex/</link><description>Recent content in Futex on keep doing</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 05 May 2025 17:45:55 +0800</lastBuildDate><atom:link href="https://cloudedseal.github.io/tags/futex/index.xml" rel="self" type="application/rss+xml"/><item><title>Syscall Futex</title><link>https://cloudedseal.github.io/blog/syscall-futex/</link><pubDate>Mon, 05 May 2025 17:45:55 +0800</pubDate><guid>https://cloudedseal.github.io/blog/syscall-futex/</guid><description>
&lt;p>&lt;strong>Futex (Fast Userspace Mutex)&lt;/strong>&lt;/p>
&lt;p>A &lt;strong>futex&lt;/strong> is a Linux kernel system call that provides a fast and efficient mechanism for implementing &lt;code>user-space synchronization&lt;/code> primitives, such as mutexes, semaphores, and condition variables. It &lt;code>minimizes&lt;/code> kernel involvement &lt;code>in uncontended cases&lt;/code>, reducing overhead by handling synchronization in userspace when possible.&lt;/p>
&lt;blockquote>
&lt;p>Futexes split synchronization into &lt;strong>user-space atomics&lt;/strong> (fast) and &lt;strong>kernel-assisted blocking&lt;/strong> (slow), optimizing for the common case. The boundary is enforced by hardware (CPU modes) and the need for kernel-managed resources (scheduling, interrupts).&lt;/p>
&lt;/blockquote>
&lt;h2>&lt;strong>How Futex Works?&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="how-futex-works">&lt;/span>
&lt;a href="#how-futex-works" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;ol>
&lt;li>没有竞争，CAS 后直接获取锁，不涉及到 syscall&lt;/li>
&lt;li>有竞争, futex_wait 让线程 sleep, 等待其他线程 futex_wake 唤醒&lt;/li>
&lt;/ol>
&lt;p>大多数时候是没有竞争的，所以就减少了内核的干预。&lt;/p>
&lt;h3>&lt;strong>futex 设计原则&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="futex-设计原则">&lt;/span>
&lt;a href="#futex-%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;h4>&lt;strong>Avoid Kernel Calls When Possible&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="avoid-kernel-calls-when-possible">&lt;/span>
&lt;a href="#avoid-kernel-calls-when-possible" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>Use &lt;code>atomic operations&lt;/code> for &lt;code>uncontended cases&lt;/code> (fast path).&lt;/li>
&lt;li>Only call the kernel when blocking is required (slow path).&lt;/li>
&lt;/ul>
&lt;h4>&lt;strong>Kernel as a Backstop&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="kernel-as-a-backstop">&lt;/span>
&lt;a href="#kernel-as-a-backstop" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>The kernel handles complex tasks like:
&lt;ul>
&lt;li>Managing wait queues.&lt;/li>
&lt;li>Guaranteeing fairness/priority in thread wakeup.&lt;/li>
&lt;li>Handling signals/interrupts during blocking.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4>&lt;strong>Spurious Wakeups&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="spurious-wakeups">&lt;/span>
&lt;a href="#spurious-wakeups" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>The kernel may wake threads even if the futex value hasn’t changed (e.g., due to &lt;code>signals&lt;/code>).&lt;/li>
&lt;li>&lt;strong>User-space must &lt;code>recheck&lt;/code> the futex value&lt;/strong> after wakeup (e.g., loop in &lt;code>lock()&lt;/code>).&lt;/li>
&lt;/ul>
&lt;h3>&lt;strong>为啥需要减少内核的干预?&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="为啥需要减少内核的干预">&lt;/span>
&lt;a href="#%e4%b8%ba%e5%95%a5%e9%9c%80%e8%a6%81%e5%87%8f%e5%b0%91%e5%86%85%e6%a0%b8%e7%9a%84%e5%b9%b2%e9%a2%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>Kernel calls (system calls) are &lt;strong>expensive&lt;/strong> compared to user-space operations.&lt;/p>
&lt;h4>&lt;strong>Context Switch Overhead&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="context-switch-overhead">&lt;/span>
&lt;a href="#context-switch-overhead" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>When a thread enters the kernel (e.g., via &lt;code>syscall&lt;/code>), the CPU must:
&lt;ul>
&lt;li>Save user-space registers. 保存用户空间寄存器&lt;/li>
&lt;li>Switch to kernel mode (privileged CPU state). CPU 模式切换到特权模式&lt;/li>
&lt;li>Run kernel code (e.g., scheduler, wait queues). 执行内核代码，比如调度器&lt;/li>
&lt;li>Restore user-space state afterward. 恢复用户空间寄存器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>This process takes &lt;strong>hundreds to thousands of CPU cycles&lt;/strong>, adding latency.&lt;/li>
&lt;/ul>
&lt;h4>&lt;strong>Scalability&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="scalability">&lt;/span>
&lt;a href="#scalability" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>Frequent kernel calls create contention in the &lt;code>kernel’s internal data structures&lt;/code> (e.g., locks for process/thread management).&lt;/li>
&lt;li>Kernel resources are shared &lt;code>across all processes&lt;/code>, so overuse hurts overall system performance. 所有进程共享内核资源&lt;/li>
&lt;/ul>
&lt;h4>&lt;strong>Fast-Path Optimization&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="fast-path-optimization">&lt;/span>
&lt;a href="#fast-path-optimization" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>Most synchronization operations (e.g., locking a mutex) are &lt;strong>uncontended&lt;/strong> (no other thread holds the lock).&lt;/li>
&lt;li>Handling these cases purely in user-space avoids kernel interaction entirely.&lt;/li>
&lt;/ul>
&lt;h4>&lt;strong>User Space and Kernel 边界&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="user-space-and-kernel-边界">&lt;/span>
&lt;a href="#user-space-and-kernel-%e8%be%b9%e7%95%8c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>The boundary is defined by &lt;strong>CPU privilege levels&lt;/strong> and the need for kernel-managed resources:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>User Space&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Kernel Space&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Runs in unprivileged CPU mode (ring 3).&lt;/td>
&lt;td>Runs in privileged CPU mode (ring 0).&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Directly manipulates user memory.&lt;/td>
&lt;td>Manages hardware, interrupts, scheduling.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Uses atomic CPU instructions (e.g., &lt;code>cmpxchg&lt;/code>).&lt;/td>
&lt;td>Uses system calls (e.g., &lt;code>futex&lt;/code>, &lt;code>sched_yield&lt;/code>).&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Handles &amp;ldquo;fast path&amp;rdquo; (uncontended case).&lt;/td>
&lt;td>Manages &amp;ldquo;slow path&amp;rdquo; (blocking/waking threads).&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2>&lt;strong>Futex: Balancing User/Kernel Responsibilities&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="futex-balancing-userkernel-responsibilities">&lt;/span>
&lt;a href="#futex-balancing-userkernel-responsibilities" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>&lt;code>futex&lt;/code> 横跨 user/kernel 两个空间&lt;/p>
&lt;h3>&lt;strong>User-Space Fast Path (No Contention)&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="user-space-fast-path-no-contention">&lt;/span>
&lt;a href="#user-space-fast-path-no-contention" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Atomic Compare-and-Swap (CAS):&lt;/strong>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">atomic_compare_exchange_strong&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">futex&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// Pure user-space
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>If the lock is free (&lt;code>futex == 0&lt;/code>), the thread acquires it &lt;strong>without involving the kernel&lt;/strong>.&lt;/li>
&lt;li>This is a single CPU instruction (e.g., &lt;code>lock cmpxchg&lt;/code> on x86), blazing fast.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3>&lt;strong>Kernel Slow Path (Contention)&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="kernel-slow-path-contention">&lt;/span>
&lt;a href="#kernel-slow-path-contention" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;h4>&lt;strong>Blocking with &lt;code>FUTEX_WAIT&lt;/code>&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="blocking-with">&lt;/span>
&lt;a href="#blocking-with" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">syscall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SYS_futex&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">futex&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">FUTEX_WAIT&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...);&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>If the lock is held (&lt;code>futex == 1&lt;/code>), the thread asks the kernel to &lt;strong>block it&lt;/strong> until the lock is freed.&lt;/li>
&lt;li>The kernel adds the thread to a &lt;code>wait queue&lt;/code> and &lt;code>schedules other threads&lt;/code>.&lt;/li>
&lt;/ul>
&lt;h4>&lt;strong>Waking with &lt;code>FUTEX_WAKE&lt;/code>&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="waking-with">&lt;/span>
&lt;a href="#waking-with" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">syscall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SYS_futex&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">futex&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">FUTEX_WAKE&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...);&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>&lt;code>On unlock&lt;/code>, the kernel &lt;code>wakes&lt;/code> one blocked thread.&lt;/li>
&lt;li>This involves &lt;code>scheduler&lt;/code> logic (kernel responsibility).&lt;/li>
&lt;/ul>
&lt;h3>&lt;strong>Futex 主要操作&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="futex-主要操作">&lt;/span>
&lt;a href="#futex-%e4%b8%bb%e8%a6%81%e6%93%8d%e4%bd%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>&lt;strong>&lt;code>FUTEX_WAIT&lt;/code>&lt;/strong>: Puts the calling thread to &lt;code>sleep&lt;/code> if the futex word matches the expected value.&lt;/li>
&lt;/ul>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;pre>&lt;code> If *uaddr == val, the thread goes to sleep (blocks).
If *uaddr != val, the call returns immediately with EAGAIN.
If a timeout is set, the thread may also wake up due to timeout (ETIMEDOUT).&lt;/code>&lt;/pre>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>&lt;strong>&lt;code>FUTEX_WAKE&lt;/code>&lt;/strong>: Wakes up a specified number of threads waiting on the futex.&lt;/li>
&lt;li>&lt;strong>&lt;code>FUTEX_WAIT_BITSET&lt;/code> / &lt;code>FUTEX_WAKE_BITSET&lt;/code>&lt;/strong>: Advanced operations for conditional waits using bitmasks (e.g., for condition variables).&lt;/li>
&lt;/ul>
&lt;h3>&lt;strong>工作流程示例&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="工作流程示例">&lt;/span>
&lt;a href="#%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b%e7%a4%ba%e4%be%8b" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>Thread A acquires the lock:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>CAS succeeds in user space (&lt;code>futex&lt;/code> becomes 1).&lt;/li>
&lt;li>No kernel interaction.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Thread B tries to acquire the lock:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>CAS fails (futex is 1).&lt;/li>
&lt;li>Calls &lt;code>FUTEX_WAIT&lt;/code> to block (kernel involvement).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Thread A releases the lock:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Sets &lt;code>futex&lt;/code> to 0 (user space).&lt;/li>
&lt;li>Calls &lt;code>FUTEX_WAKE&lt;/code> to unblock Thread B (kernel).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>&lt;strong>Why This Matters in Practice?&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="why-this-matters-in-practice">&lt;/span>
&lt;a href="#why-this-matters-in-practice" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Performance:&lt;/strong> A futex-based mutex can be &lt;strong>10–100x faster&lt;/strong> than a traditional kernel-only mutex under low contention.&lt;/li>
&lt;li>&lt;strong>Scalability:&lt;/strong> Reduces kernel lock contention in highly parallel workloads (e.g., databases, game engines).&lt;/li>
&lt;li>&lt;strong>Flexibility:&lt;/strong> User-space can implement custom synchronization logic (e.g., adaptive mutexes, read/write locks).&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Core Concept&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>A &lt;strong>futex word&lt;/strong> (a 32-bit integer in shared memory) acts as the synchronization variable. 和平台无关, 都是 32bit&lt;/li>
&lt;li>Threads use atomic operations (e.g., compare-and-swap) to manipulate this word in userspace.&lt;/li>
&lt;li>Kernel intervention occurs &lt;strong>only during contention&lt;/strong> (e.g., when a thread must wait).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Acquiring a Lock (&lt;code>Uncontended Case&lt;/code>)&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>A thread attempts to atomically set the futex word from &lt;code>0&lt;/code> (unlocked) to &lt;code>1&lt;/code> (locked).&lt;/li>
&lt;li>If successful, the lock is acquired without a system call.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Acquiring a Lock (&lt;code>Contended Case&lt;/code>)&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>If the lock is already held (&lt;code>futex_word == 1&lt;/code>), the thread calls &lt;code>futex_wait(&amp;amp;futex_word, 1)&lt;/code> to block.&lt;/li>
&lt;li>The kernel checks if the futex word is still &lt;code>1&lt;/code> and puts the thread to sleep, avoiding race conditions.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Releasing a Lock&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>The thread sets the futex word back to &lt;code>0&lt;/code> atomically.&lt;/li>
&lt;li>It then calls &lt;code>futex_wake(&amp;amp;futex_word, 1)&lt;/code> to wake up one waiting thread.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Handling Spurious Wakeups&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>After waking, threads &lt;strong>re-check&lt;/strong> the futex word to ensure the lock is available before proceeding.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>&lt;strong>例子理解&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="例子理解">&lt;/span>
&lt;a href="#%e4%be%8b%e5%ad%90%e7%90%86%e8%a7%a3" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div class="filename not-prose" dir="auto">futex_demo.c&lt;/div>&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;linux/futex.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;sys/syscall.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;pthread.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Futex word (shared between threads)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">futex_var&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 0 = unlocked, 1 = locked
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Wrapper for futex_wait syscall
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">futex_wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">uaddr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">val&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">syscall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SYS_futex&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uaddr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">FUTEX_WAIT&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">val&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Wrapper for futex_wake syscall
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">futex_wake&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">uaddr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">syscall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SYS_futex&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uaddr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">FUTEX_WAKE&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Thread function with custom sleep time
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">thread_func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">arg&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">sleep_time&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">arg&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// Cast void* to int*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Try to acquire lock (using GCC atomic compare-and-swap)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">expected&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="nf">__sync_bool_compare_and_swap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">futex_var&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Contended case: wait for wakeups
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Thread %lu acquired the lock failed&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nf">pthread_self&lt;/span>&lt;span class="p">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">futex_wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">futex_var&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Critical section (simulate work with custom sleep)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Thread %lu acquired the lock success, sleeping for %d seconds&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">pthread_self&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">sleep_time&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sleep_time&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// Customizable sleep duration
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Release lock
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">futex_var&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">futex_wake&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">futex_var&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Define sleep durations for each thread
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">sleep1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// First thread sleeps for 1 second
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">sleep2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// Second thread sleeps for 3 seconds
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">sleep3&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Create threads
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">pthread_t&lt;/span> &lt;span class="n">t1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">t2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">t3&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%p&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">futex_var&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">pthread_create&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">thread_func&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">sleep1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">pthread_create&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">t2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">thread_func&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">sleep2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">pthread_create&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">t3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">thread_func&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">sleep3&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Wait for threads to finish
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">pthread_join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">pthread_join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">t2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">pthread_join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">t3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-8">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;blockquote>
&lt;p>gcc -g -pthread -std=gnu11 futex_demo.c -o futex_demo&lt;/p>
&lt;/blockquote>
&lt;h2>&lt;strong>什么是 Spurious Wakeup?&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="什么是-spurious-wakeup">&lt;/span>
&lt;a href="#%e4%bb%80%e4%b9%88%e6%98%af-spurious-wakeup" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>A &lt;strong>spurious wakeup&lt;/strong> occurs when a thread waiting on a synchronization primitive (e.g., a condition variable, futex, or semaphore) &lt;strong>wakes up without being explicitly signaled or broadcasted&lt;/strong>. This means the thread resumes execution even though no other thread modified the condition it was waiting for.&lt;/p>
&lt;p>Spurious wakeups are &lt;strong>not errors&lt;/strong> in the system.
they are a design trade-off in low-level synchronization mechanisms like futexes to &lt;strong>avoid unnecessary overhead&lt;/strong> in kernel-space implementations.&lt;/p>
&lt;h3>&lt;strong>为啥需要 spurious Wakeups?&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="为啥需要-spurious-wakeups">&lt;/span>
&lt;a href="#%e4%b8%ba%e5%95%a5%e9%9c%80%e8%a6%81-spurious-wakeups" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>spurious wakeups are allowed for &lt;strong>performance and implementation efficiency&lt;/strong>, particularly in systems like Linux futexes.&lt;/p>
&lt;p>为了性能和高效的实现需要 spurious wakeups&lt;/p>
&lt;h4>1. &lt;strong>Kernel Optimization&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="1-kernel-optimization">&lt;/span>
&lt;a href="#1-kernel-optimization" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>The Linux kernel uses shared data structures (e.g., wait queues) for threads waiting on a futex. If multiple threads are waiting on the same futex word, the kernel may wake up &lt;strong>more than one thread&lt;/strong> (even if only one is needed) to reduce contention and latency.&lt;/li>
&lt;li>This avoids the overhead of tracking exactly which thread should wake up.&lt;/li>
&lt;/ul>
&lt;h4>2. &lt;strong>Signal Handling&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="2-signal-handling">&lt;/span>
&lt;a href="#2-signal-handling" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>A thread waiting on a futex may be interrupted by a &lt;strong>signal&lt;/strong> (e.g., &lt;code>SIGINT&lt;/code>, &lt;code>SIGALRM&lt;/code>). The kernel wakes up the thread to handle the signal, even if the futex condition hasn’t changed.&lt;/li>
&lt;/ul>
&lt;h4>3. &lt;strong>Hardware/Architecture Constraints&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="3-hardwarearchitecture-constraints">&lt;/span>
&lt;a href="#3-hardwarearchitecture-constraints" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>Some architectures or hardware may not guarantee atomicity between checking the condition and sleeping, leading to race conditions that require re-checking after waking.&lt;/li>
&lt;/ul>
&lt;h2>&lt;strong>什么情况会发生 Spurious Wakeups?&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="什么情况会发生-spurious-wakeups">&lt;/span>
&lt;a href="#%e4%bb%80%e4%b9%88%e6%83%85%e5%86%b5%e4%bc%9a%e5%8f%91%e7%94%9f-spurious-wakeups" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Scenario&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Multiple Waiters&lt;/strong>&lt;/td>
&lt;td>When many threads wait on the same futex, the kernel may wake multiple threads (e.g., via &lt;code>FUTEX_WAKE&lt;/code>) even if only one is needed.&lt;br/> 多个等待同一个 futex 的线程, 被 os 一并唤醒, 但最终只有一个获取 futex&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Signal Interruption&lt;/strong>&lt;/td>
&lt;td>A thread is interrupted by a signal (e.g., Ctrl+C), causing it to wake up prematurely.&lt;br> 虽然进程 sleep 了, 但是仍可以被 os 唤醒处理信号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Timeout Expiration&lt;/strong>&lt;/td>
&lt;td>If a timeout is set (e.g., &lt;code>FUTEX_WAIT_BITSET&lt;/code> with a timeout), the thread may wake up due to the timeout, even if the condition hasn’t changed.&lt;br/> 设置了超时, 超时后可以被 os 唤醒&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Kernel Preemption&lt;/strong>&lt;/td>
&lt;td>In high-load scenarios, the kernel may preempt a waiting thread for scheduling reasons. &lt;br/> 被 os 抢占调度唤醒&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3>&lt;strong>如何处理 Spurious Wakeups?&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="如何处理-spurious-wakeups">&lt;/span>
&lt;a href="#%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86-spurious-wakeups" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>To handle spurious wakeups correctly, &lt;strong>always re-check the condition&lt;/strong> after waking up. This is a fundamental rule in concurrent programming.&lt;/p>
&lt;h4>&lt;strong>例子1 重新检查条件&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="例子1-重新检查条件">&lt;/span>
&lt;a href="#%e4%be%8b%e5%ad%901-%e9%87%8d%e6%96%b0%e6%a3%80%e6%9f%a5%e6%9d%a1%e4%bb%b6" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Shared futex word (0 = unlocked, 1 = locked)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">futex_var&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Thread attempts to acquire the lock
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="nf">__sync_bool_compare_and_swap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">futex_var&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Wait for wakeups if futex_var is still 1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">futex_wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">futex_var&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>Here’s what happens:&lt;/p>
&lt;ol>
&lt;li>If &lt;code>futex_wait&lt;/code> returns due to a spurious wakeup, the thread &lt;strong>re-checks the condition&lt;/strong> (&lt;code>futex_var == 1&lt;/code>) in the loop.&lt;/li>
&lt;li>If the condition is still true, the thread calls &lt;code>futex_wait&lt;/code> again.&lt;/li>
&lt;li>If the condition is now false (e.g., another thread released the lock), the thread proceeds.&lt;/li>
&lt;/ol>
&lt;h4>&lt;strong>例子2 重新检查条件&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="例子2-重新检查条件">&lt;/span>
&lt;a href="#%e4%be%8b%e5%ad%902-%e9%87%8d%e6%96%b0%e6%a3%80%e6%9f%a5%e6%9d%a1%e4%bb%b6" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">pthread_mutex_lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">condition_met&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">pthread_cond_wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">cond&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// Releases mutex, waits for signal
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Re-check condition here (spurious wakeups handled by the loop)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">pthread_mutex_unlock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>The &lt;code>while&lt;/code> loop ensures that spurious wakeups are harmless.&lt;/p>
&lt;h3>&lt;strong>Why Not Prevent Spurious Wakeups?&lt;/strong>&lt;span class="hx-absolute -hx-mt-20" id="why-not-prevent-spurious-wakeups">&lt;/span>
&lt;a href="#why-not-prevent-spurious-wakeups" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>Preventing spurious wakeups would require &lt;strong>strict guarantees&lt;/strong> from the kernel or library, which could introduce significant overhead. For example:&lt;/p>
&lt;ul>
&lt;li>Tracking exactly which thread should wake up (e.g., via a queue).&lt;/li>
&lt;li>Adding memory barriers or locks to ensure atomicity between checking and sleeping.&lt;/li>
&lt;/ul>
&lt;p>By allowing spurious wakeups, systems like futexes remain lightweight and scalable for high-performance applications.&lt;/p></description></item></channel></rss>